# ============================================================
# PHLOW ‚Äî AI Agent Native Language (LOCAL / PRONTO PRA USO)
# ============================================================

version: "1"

# ---------- M√ìDULOS (somente locais/mock) ----------
modules:
  - module: log

  - module: budget.quota
    config:
      default:
        tokens_per_hour: 60000
        tool_calls_per_min: 60

  - module: auth.policy
    config:
      deny_by_default: true
      log_violations: true
      mode: enforce  # enforce | observe

  # Mem√≥ria vetorial (em mem√≥ria)
  - module: memory.vector
    config:
      provider: inmemory            # alternativo: pgvector, qdrant, etc.
      collection: "kb_general"
      embedding_model: "mock-mini"  # mock emb. determin√≠stica
      similarity: "cosine"
      normalize: true
      default_limit: 5

  # KV (em mem√≥ria)
  - module: memory.kv
    config:
      provider: inmemory
      namespace: "agent:demo"

  # LLM Mock determin√≠stico (sem rede)
  - module: llm.mock
    config:
      # O mock segue regras simples: concatena entradas, aplica "pol√≠ticas"
      # de concis√£o e pode devolver JSON determin√≠stico quando solicitado.
      seed: 42
      max_tokens: 800

  # Canal de resposta (stdout / console)
  - module: channel.reply
    config:
      provider: stdout

  # HTTP client mock (√∫til p/ testar planners que ‚Äúagem‚Äù)
  - module: http.client
    config:
      provider: mock
      mock_routes:
        - when:
            method: POST
            url: "https://api.local/echo"
          respond:
            status: 200
            json:
              ok: true
              echo: "{{ request.json }}"

  # Scheduler CRON local
  - module: scheduler.cron
    config:
      timezone: "America/Sao_Paulo"

# ---------- TOOLS (pipelines) ----------
tools:
  # ==========================================================
  # Seed de conhecimento: carrega KB local em mem√≥ria vetorial
  # ==========================================================
  - name: seed_kb
    steps:
      - log.info:
          message: "Carregando KB local em mem√≥ria‚Ä¶"

      - id: chunks
        payload: |
          // retorna uma lista de objetos {id, text}
          let docs = [
            { id: "faq.reembolso", text: "Reembolso: at√© 7 dias √∫teis ap√≥s a solicita√ß√£o." },
            { id: "faq.suporte",   text: "Suporte: segunda a sexta, 9h-18h (hor√°rio de Bras√≠lia)." },
            { id: "faq.entrega",   text: "Prazo de entrega: 3 a 5 dias √∫teis nas capitais." },
            { id: "faq.cancel",    text: "Cancelamento: sem custo at√© 24h ap√≥s a compra." },
            { id: "faq.planos",    text: "Planos: Starter R$49/m√™s, Pro R$149/m√™s, Enterprise sob consulta." },
          ];
          phs_return docs;

      - foreach: "{{ steps.chunks.data }}"
        steps:
          - memory.vector.upsert:
              id: "{{ item.id }}"
              text: "{{ item.text }}"

      - channel.reply.send:
          text: "‚úÖ KB carregada: {{ steps.chunks.data.len }} registros."

  # ==========================================================
  # Handler principal: classifica ‚Üí RAG (limit) ‚Üí planeja ‚Üí confirma/age ‚Üí responde
  # ==========================================================
  - name: handler_user_message
    steps:
      # Or√ßamento
      - budget.quota.check:
          scope: "agent.concierge"
          need:
            tokens: 2000
            tool_calls: 4

      # Classifica√ß√£o de inten√ß√£o + entidades (JSON determin√≠stico do mock)
      - id: intent
        llm.mock.generate:
          mode: "json"  # mock tenta produzir JSON est√°vel
          system: |
            Classifique inten√ß√£o em {FAQ, ACTION, OTHER} e extraia entidades.
            Responda JSON: {"intent":"...","entities":{...}}
          input: |
            Mensagem: {{ payload.message.text }}
          capture: json

      # RAG somente para FAQ/OTHER
      - condition:
          assert: steps.intent.data.json.intent in ["FAQ","OTHER"]
        then:
          - id: facts
            memory.vector.search:
              query: payload.message.text
              limit: 6

      # Planejamento simples (decide a√ß√£o/confirm)
      - id: plan
        llm.mock.generate:
          mode: "json"
          system: |
            Gere um plano em JSON:
            {"need_confirm":bool,"action":"NONE|HTTP","summary":"...","params":{"url": "...", "body": {...}}}
            Seja conservador: pe√ßa confirma√ß√£o se for acionar APIs externas.
          input: |
            Intent: {{ steps.intent.data.json.intent }}
            Entities: {{ steps.intent.data.json.entities }}
            Facts: {{ steps.facts.data.items }}
          capture: json

      # Confirmar a√ß√£o se necess√°rio
      - condition:
          assert: steps.plan.data.json.need_confirm == true
        then:
          - memory.kv.set:
              key: "pending_plan:{{ payload.user.id }}"
              value: "{{ steps.plan.data.json }}"
          - channel.reply.send:
              text: |
                Posso proceder? {{ steps.plan.data.json.summary }}
                Responda "sim" para continuar ou "n√£o" para cancelar.
          - stop: true

      # Executar a√ß√£o (apenas HTTP mock neste exemplo)
      - condition:
          assert: steps.plan.data.json.action == "HTTP"
        then:
          - id: http_result
            http.client.post:
              url: "{{ steps.plan.data.json.params.url }}"
              json: "{{ steps.plan.data.json.params.body }}"
              # Atributos adicionais s√£o gravados no span nativo do Phlow
              otel.attributes:
                action: "HTTP"
                url: "{{ steps.plan.data.json.params.url }}"

      # Compor resposta final (objetiva)
      - id: answer
        llm.mock.generate:
          mode: "text"
          system: |
            Voc√™ √© objetivo e claro. Se houve a√ß√£o, resuma o que foi feito.
            Se n√£o, responda com base nos fatos recuperados (se existirem).
          input: |
            Mensagem: {{ payload.message.text }}
            Inten√ß√£o: {{ steps.intent.data.json.intent }}
            Fatos: {{ steps.facts.data.items }}
            Resultado HTTP: {{ steps.http_result.data }}
          capture: text

      - channel.reply.send:
          text: "{{ steps.answer.data.text }}"

  # ==========================================================
  # Confirma√ß√£o do usu√°rio (‚Äúsim‚Äù/‚Äún√£o‚Äù) para um plano pendente
  # ==========================================================
  - name: handler_user_confirmation
    steps:
      - id: msg
        |
          let txt = lower(trim(payload.message.text));
          phs_return { confirm: (txt == "sim"), cancel: (txt == "n√£o" || txt == "nao") };

      - condition:
          assert: steps.msg.data.confirm == false && steps.msg.data.cancel == false
        then:
          - channel.reply.send:
              text: "Por favor, responda com 'sim' para executar ou 'n√£o' para cancelar."
          - stop: true

      - memory.kv.get:
          key: "pending_plan:{{ payload.user.id }}"

      - condition:
          assert: steps['memory.kv.get'].data.value == null
        then:
          - channel.reply.send:
              text: "N√£o h√° nenhuma a√ß√£o pendente para confirmar."
          - stop: true

      - condition:
          assert: steps.msg.data.cancel == true
        then:
          - memory.kv.del:
              key: "pending_plan:{{ payload.user.id }}"
          - channel.reply.send:
              text: "‚úÖ A√ß√£o cancelada."
          - stop: true

      # Executa o plano previamente salvo
      - id: plan
        |
          phs_return steps['memory.kv.get'].data.value;

      - condition:
          assert: steps.plan.data.action == "HTTP"
        then:
          - id: http_result
            http.client.post:
              url: "{{ steps.plan.data.params.url }}"
              json: "{{ steps.plan.data.params.body }}"

      - memory.kv.del:
          key: "pending_plan:{{ payload.user.id }}"

      - channel.reply.send:
          text: "‚úÖ A√ß√£o executada com sucesso."

  # ==========================================================
  # Validador: revisa a √∫ltima resposta (simples)
  # ==========================================================
  - name: handler_validate_last_answer
    steps:
      - id: review
        llm.mock.generate:
          mode: "json"
          system: |
            Avalie clareza/objetividade. Responda:
            {"ok":bool,"suggested":"..."}
          input: |
            Mensagem: {{ payload.message.text }}
            Resposta: {{ payload.answer }}
          capture: json

      - condition:
          assert: steps.review.data.json.ok == false
        then:
          - channel.reply.send:
              text: "{{ steps.review.data.json.suggested }}"
        else:
          - log.info:
              message: "Valida√ß√£o OK"

  # ==========================================================
  # CRON di√°rio: resumo de uso simulado
  # ==========================================================
  - name: daily_digest
    steps:
      - memory.kv.get:
          key: "usage:tokens:last_24h"
      - id: digest
        llm.mock.generate:
          mode: "text"
          system: "Crie um resumo executivo em 3 bullets."
          input: |
            M√©tricas (mock): {{ steps['memory.kv.get'].data.value }}
          capture: text
      - channel.reply.send:
          text: "üìä Daily Digest\n{{ steps.digest.data.text }}"

# ---------- AGENTES ----------
agents:
  concierge:
    description: |
      Concierge local. Responda curto, pe√ßa confirma√ß√£o antes de a√ß√µes.
    tasks:
      - Confirmar antes de acionar ferramentas externas.
      - Responder de forma objetiva usando fatos quando existirem.
    behavior:
      temperature: 0.2
      max_tokens: 400
    policies:
      allow:
        - channel.reply.send
        - memory.vector.search
        - memory.vector.upsert
        - memory.kv.*
        - llm.mock.generate
        - http.client.post where { url like "https://api.local/*" }
      deny:
        - http.client.get         # desabilitado para o exemplo
    budget:
      tokens_per_hour: 30000
      tool_calls_per_min: 30
    tools:
      - seed_kb
      - handler_user_message
      - handler_user_confirmation
    triggers:
      - on: system.bootstrap
        do:
          - tool: seed_kb
      - on: user.message
        when: lower(trim(payload.message.text)) not in ["sim","n√£o","nao"]
        do:
          - tool: handler_user_message
      - on: user.message
        when: lower(trim(payload.message.text)) in ["sim","n√£o","nao"]
        do:
          - tool: handler_user_confirmation

  validator:
    description: "Validador local. Sugere corre√ß√µes quando necess√°rio."
    behavior:
      temperature: 0.1
      max_tokens: 200
    policies:
      allow:
        - llm.mock.generate
        - channel.reply.send
      deny: []
    tools:
      - handler_validate_last_answer
    triggers:
      - on: agent.concierge.replied
        do:
          - tool: handler_validate_last_answer
            with:
              message: "{{ event.payload.message }}"
              answer: "{{ event.payload.answer }}"

  scheduler:
    description: "Agente de tarefas agendadas (local)."
    policies:
      allow:
        - scheduler.cron.register
        - channel.reply.send
        - llm.mock.generate
        - memory.kv.get
      deny: []
    tools:
      - daily_digest
    triggers:
      - on: system.bootstrap
        do:
          - scheduler.cron.register:
              id: "daily_digest_9am"
              cron: "0 9 * * *"
              tool: "daily_digest"

# ---------- FILAS & ROTEAMENTO (opcional, local) ----------
queues:
  - name: "agents.concierge"
    max_inflight: 8
  - name: "agents.validator"
    max_inflight: 4

routing:
  - event: "user.message"
    to: "agents.concierge"
  - event: "agent.concierge.replied"
    to: "agents.validator"
  - event: "system.bootstrap"
    to: "agents.scheduler"

# ---------- DEBUG ----------
debug:
  breakpoints:
    - on_error: true
  replay:
    capture:
      prompts: true
      tool_io: true
      seeds: true
